---
title: 筛选素数
date: 2020-08-04 09:28:19
tags: 
	- 埃氏筛法
	- 素数
categories: 数论
---
# 定义
   素数：一个大于1的自然数，且除了1和它本身外，不能被其他自然数整除的数叫素数。

# 无脑暴力 :smile:
   ~~上去就是二重循环暴力穷举~~ 



# 埃氏筛法

   筛选[2,n]中素数的最简单的方法是——埃氏筛法
代码如下：
	

``` cpp
#include<iostream>
using namespace std;
#define MAX 1000
bool u[MAX+5];
int prime[MAX];
int num = 0; //第一个素数下标为1
int main()
{
    for(int i = 2;i <= MAX;i ++)
	{
    	u[i] = true;
	}
	for(int i = 2;i <= MAX;i ++) //遍历每个数，筛去它的倍数
	{
    	if(u[i])
    	{
	    	for(int j = 2;j*i <= MAX;j ++)
			{
	    		u[j*i] = false;   //合数作为素数的倍数被筛掉
    		}
		}
	}
	for(int i = 2;i <= MAX;i ++)
	{
        if(u[i])
        {
            prime[++num] = i;
        }
	}
    for(int i = 2;i <= num;i ++)
    {
        cout<<prime[i]<<endl;
    }
    return 0;
}
```
该算法中，合数是作为素数的倍数被筛去的。该算法的复杂度为O(n*log log <sub>n</sub>)。

---
上述筛选的方法中会存在重复筛选的情况，比如6会被2*3和 3\*2筛去。

因此，如果每个合数仅被它最小的质因数筛去，则算法效率可以大幅提升，由此改进的算法称为

# 欧拉筛法

代码如下：

```cpp
#include <iostream>
using namespace std;
#define MAX 1000
bool u[MAX+5];
int prime[MAX];
int num = 0;
int main()
{
    for(int i = 2;i <= MAX;i ++)
    {
		u[i] = true;
    }
    for(int i = 2;i <= MAX;i ++)
    {
        if(u[i])
        {	
            prime[++num] = i;   //下标从1开始,这个可以自己来定
            //这一步是选出最小的素数，因为要用这个最小的素数作为被筛合数的最小质因数去筛去合数，上面那个普通的算法中我们也可以这样写。
        }
        for(int j = 1;j <= num;j ++)
        {
            if(i*prime[j] > MAX)
            {
                break;
            }
            u[i*prime[j]] = false;
            if(i % prime[j]==0)
            {
                break;
            }
        }
    }
    for(int i = 2;i <= num;i ++)
    {
        cout<<prime[i]<<endl;
    }
    return 0;
}
```
这里不是筛去i的倍数，而是用prime[j]作为最小质因数，i作为倍数来筛去合数
![输出前十个循环](https://i.loli.net/2020/08/04/ThCr1Kq4SPZwFet.png)