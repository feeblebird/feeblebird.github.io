---
title: 筛选素数
date: 2020-08-04 09:28:19
tags: 
	- 埃氏筛法
	- 欧拉筛法
	- 素数筛选
categories: 数论
---
# 定义
   素数：一个大于1的自然数，且除了1和它本身外，不能被其他自然数整除的数叫素数。

# 无脑暴力 :smile:
   ~~上去就是二重循环暴力穷举~~ 



# 埃氏筛法

* 筛选[2,n]中素数的最简单的方法是——埃氏筛法
* 代码如下：
	

``` cpp
#include<iostream>
using namespace std;
#define MAX 1000
bool u[MAX+5];
int prime[MAX];
int num = 0; //第一个素数下标为1
int main()
{
    for(int i = 2;i <= MAX;i ++)
	{
    	u[i] = true;
	}
	for(int i = 2;i <= MAX;i ++) //遍历每个数，筛去它的倍数
	{
    	if(u[i])
    	{
	    	for(int j = 2;j*i <= MAX;j ++)
			{
	    		u[j*i] = false;   //合数作为素数的倍数被筛掉
    		}
		}
	}
	for(int i = 2;i <= MAX;i ++)
	{
        if(u[i])
        {
            prime[++num] = i;
        }
	}
    for(int i = 2;i <= num;i ++)
    {
        cout<<prime[i]<<endl;
    }
    return 0;
}
```
该算法中，合数是作为素数的倍数被筛去的。该算法的复杂度为O(n*log log <sub>n</sub>)。

---
上述筛选的方法中会存在重复筛选的情况，比如6会被2\*3和 3\*2筛去。

因此，如果每个合数仅被它最小的质因数筛去，则算法效率可以大幅提升，由此改进的算法称为

# 欧拉筛法

* 代码如下：

```cpp
#include <iostream>
using namespace std;
#define MAX 1000
bool u[MAX+5];
int prime[MAX];
int num = 0;
int main()
{
    for(int i = 2;i <= MAX;i ++)
    {
		u[i] = true;
    }
    for(int i = 2;i <= MAX;i ++)
    {
        if(u[i])
        {	
            prime[++num] = i;   //下标从1开始,这个可以自己来定
            //这一步是选出最小的素数，因为要用这个最小的素数作为被筛合数的最小质因数去筛去合数，上面那个普通的算法中我们也可以这样写。
        }
        for(int j = 1;j <= num;j ++)
        {
            if(i*prime[j] > MAX)
            {
                break;
            }
            u[i*prime[j]] = false;
            if(i % prime[j]==0)
            {
                break;
            }
        }
    }
    for(int i = 2;i <= num;i ++)
    {
        cout<<prime[i]<<endl;
    }
    return 0;
}
```
这里不是筛去i的倍数，而是用prime[j]作为最小质因数，i作为倍数来筛去合数
![输出前十个循环](https://i.loli.net/2020/08/04/ThCr1Kq4SPZwFet.png)

所以整体的思想就是用合数的最小质因子来筛去这个合数。该算法的复杂度可以优化至O(n)

> 对于i % prime[j] == 0 就break得解释：
>
> > 如果等于零，则说明 i = k * prime[j] 。此时如果不跳出循环的话，则下一个筛去的素数应该是：i \* prime[j+1] = ( k \* prime[j] ) \* prime[j+1] = (k \* prime[j+1]) * prime[j]  所以出现了重复。 也就是说这次被筛去的合数会在后面再次被筛选。



---

# 欧拉筛法的证明
![欧拉筛法的线性证明](https://i.loli.net/2020/08/04/VdyxvwJTYnZ4ga2.png)

> 这里的这个 p | m' 的意思是 m' % p == 0

## 具体的一些说明如下：

* n的最小质因子为p

* 则n的另一个质因子p' 大于p ,则m’ 小于 m 

* p对应着程序中的prime[j]数组，m对应着程序中的i

## 对if(i%prime[j] == 0){break;}的解释

   欧拉筛法的主要思想就是要保证所有的合数只被他的最小质因子筛去，而就是这句代码保证了这个线性筛选。

>  即要证明程序一定会执行u[p\*m] = false 和 保证不会执行 u[p' \* m'] = false

### 具体证明如下：

要证明程序一定会执行u[p\*m] = false 一定会执行则就要证明当i = m 时，~~prime数组中有p~~（就假定肯定有了，俺母鸡咋证明），且j能够循环到p

* n = p \* m 则  m = n / p。 所以`m的最小质因子不小于p` ，如果小于了p那么n的最小质因子就不是p了。所以在执行到i % prime[j] == 0 {break;} 之前一定会执行u[p\*m] = false 这句代码，所以一个合数肯定会被它的最小质因子筛除掉。

要证明程序一定不会执行u[p'\*m'] = false，即是要证明当i循环到m’时(m'<m)，j不会循环到p'。要在这之前跳出循环，因为m' = n / p' ，而`m'中一定包含p这个质因子` 。

> 根据[这里](https://baike.baidu.com/item/%E8%B4%A8%E5%9B%A0%E6%95%B0/6192269?fr=aladdin)可知，任何一个正整数都有一个独一无二的质因子分解式，而且这个质因子分解式子里面一定包括它的最小质因子，因为n = p \* m ;m也是正整数，也可以分解成一个独一无二的质因子分解式。

所以当i = m' 时，j循环到p (p < p')就会跳出循环，所以不会执行u[p'\*m'] = false 这句话