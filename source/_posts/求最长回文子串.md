---
title: 求最长回文子串
date: 2020-08-07 16:15:11
tags:
	- Manacher算法
	- 马拉车算法
	- 最长回文子串
	- 有符号类型和无符号类型数值比较陷阱
categories: 字符串处理
---
# 最长回文子串
  回文串就是一个正读和反读都一样的字符串，比如“level”或者“noon”等等就是回文串。回文子串，顾名思义，即字符串中满足回文性质的子串。比如输入字符串 "google”，由于该字符串里最长的对称子字符串是 "goog”，因此最长回文子串的长度为4。
# 使用Manachaer算法求最长回文子串

* 给出一个字符串，要求计算出这一字符串的最长回文子串的长度。如果遍历每一个字符，并以该字符为中心向两边查找，则其时间复杂度为O(*n*<sup>2</sup>)。

* Manacher算法又被称为“马拉车”算法，可以在时间复杂度为O(n)的情况下求解一个字符串的最长回文子串的长度。

* #### Manacher算法对字符串的预处理

  * 由于回文分为偶回文（例如"bccb"）和奇回文（例如"bcacb"），而在处理奇偶问题上会比较繁琐，例如，对于偶回文"bccb"，其对称重心是在两个'c'字符之间；对于奇回文"bcacb"，对称中心就是'a'字符。

  * 对此，Manacher算法在字符串首尾，及各字符间各插入一个字符，而这个字符并未出现在字符串里。例如，字符串s是"abbahopxpo"，用未出现在字符串里的'#'字符插入，得新字符串s_new是"\$#a#b#b#a#h#o#p#x#p#o"，其中，'$'是为了防止越界。在字符串S中，有一个偶回文"abba"和一个奇回文"opxpo"，分别被转换成"#a#b#b#a#"和"#o#p#x#p#o#"，回文的`长度都成了奇数` 。

    ![对字符串的预处理](https://i.loli.net/2020/08/07/3cUyC5PLBGQvzFq.png)

* #### 求解p[]数组

  * 通过预处理之后，可以统一处理奇回文字符串和偶回文字符串
  * 所以接下来要做的就是求出p[]

![求解p思路](https://i.loli.net/2020/08/07/j76WIBYFX34EUMu.png)

  


# Palindrome (POJ 3974)

* #### 题目简略概括：:articulated_lorry:

  想要求一个字符串的最长回文子串的长度，用一种比遍历更好的方法进行求解。

* #### 输入

  您的程序将对最多达30个的测试用例进行测试，每个测试用例在 一行中以最多1000000个小写字符的字符串形式给出。输入以字符串"END"开头的一行结束（为了清楚起见，用引号）

* #### 输出

  对于输入中的每个测试用例，输出测试用例编号和最长回文子串的长度

* #### 分析

  这是一道裸的用Manacher算法的题目

* #### 代码

  ```cpp
  #include <iostream>
  #include <cstring>
  #include <cstdio>
  using namespace std;
  #define N 1000005*2
  int p[N];
  char new_str[N];
  char str[N];
  int Manacher(char* str);
  int main()
  {
      int ind = 1,ans;
      while(scanf("%s",str)!=EOF)
      {
          if(str[0]=='E')
          {
              break;
          }
          ans = Manacher(str);
          printf("Case %d: %d\n",ind,ans);
          ind++;
      }
      return 0;
  }
  int Manacher(char* str)
  {
      int ans = 0;
      int lenstr = strlen(str);
      new_str[0] = '$';
      for(int i = 0;i < lenstr;i ++)//以后要特别注意无符号数和有符号数之间数值比较，因为编译器会把有符号数转换成无符号数，所以比如这个例子，int就会转换成无符号数，如果过int符号位为1，那么就会变得很大，程序就会出错，从这道题的经历来看，就会死循环
      {
          new_str[2*i+1] = '#';
          new_str[2*i+2] = str[i];
      }
      new_str[lenstr*2+1] = '#';
      new_str[lenstr*2+2] = '\0';
      int id = 0,mx = 0;
      int lennewstr = strlen(new_str);
      for(int i = 1;i < lennewstr;i ++)//以后要特别注意无符号数和有符号数之间数值比较
      {
          if(mx>i)
          {
              p[i] = min(mx-i,p[2*id-i]);
          }else
          {
              p[i] = 1;
          }
          while(new_str[i-p[i]]==new_str[i+p[i]])
          {
              p[i]++;
        }
          if(p[i]+i>mx)
          {
              mx = p[i] + i;
              id = i;
          }
          ans = max(ans,p[i]);
      }
      return ans-1;
  }
  
  ```
  
  > ~~血泪教训！！！~~ 这个题看了半天都是超时，自己改了半天实在想不通到底那里还能再节省时间，结果。。。，结果。。。，就是for循环里面strlen(str)和int的比较搞得鬼。和网上的博客对照了半天，实在没改的了试着改了这个，结果就过了。

# 要注意无符号数和有符号数直接比较的问题

* 上网查了一下，上面这个题超时的原因就是size_t类型是无符号整型，在和int比较的时候，因为编译器会将小的类型转换成大的类型，所以会把int转换成无符号数，而如果int的符号位是1之类的，那么就会转换成一个特别大的数，程序就会出错。

* 当然，出错的原因不仅仅这个，具体编程什么样子应该是不可控制的。

* ## 所以以后再用sizeof()和strlen()函数的时候，先用一个有符号变量进行强转一下。

# Best Reward (HDOJ 3613)

* #### 题目描述

  * 经过一场艰苦的战斗，李将军取得了巨大的胜利。现在，国家元首决定用荣誉和财宝来奖励他所做的伟大贡献。
  * 奖励李将军的一件财宝是一条由26种不同的宝石组成的项链，项链的长度为*n*，也就是*n*颗宝石串在一起构成了这条项链，而每颗宝石是属于26种宝石中的一种。
  * 按照传统的观点，项链是有价值的当且仅当项链是回文——项链在任何方向上看起来都一样。然而，这个项链可能一开始还不是回文。所以国家元首决定把项链切成两半，然后把它们都交给李将军。
  * 同一种类的所有宝石的价值是相同的（因为宝石的质量，宝石的价值可能是正的，也可能是负的；有些种类的宝石很漂亮，而有些宝石则看起来是普通的石头）。回文项链的价值等于宝石的价值之和，而不是回文的项链的价值为零。现在的问题是，如何切割给出的项链，使两个项链的价值之和最大，并输出这个值。

* #### 输入

  * 输入的第一行是一个整数*T*（1≤*T*≤10），表示测试用例的数量。然后给出这些测试用例的描述。
  * 对于每个测试用例，第一行是26个整数：*v*<sub>1</sub> , *v*<sub>2</sub> , ..., *v*<sub>26</sub>（\- 100≤*v*<sub>i</sub>*≤100，1≤*i≤26），表示每种宝石的价值。
  * 每个测试用例的第二行是由字符'a'到'z'组成的字符串，表示项链，不同的字符表示不同的宝石，'a'的价值是*v*<sub>1</sub>，'b'的值是*v*<sub>2</sub>，……，以此类推。字符串的长度不超过500000。
  
* #### 输出

  * 输出一个整数，李将军可以从这串项链中获得的最大值。

* #### 分析

  * 首先先用Manacher算法求出以每个字符为中心的最长回文子串的长度，然后枚举切割点，得到两个子串，由此确定每个子串的中心点；检查以该子串的中心为中心点的回文串的长度，如果回文串的长度等于该子串的长度，则该字串的所有字符的价值之和加入两个项链的价值之和；并对所有的两个项链的价值之和取最大值。

  ![枚举切割点,程序里的i是j](https://i.loli.net/2020/08/08/qkX1NKixtCTUYBv.png)

  ![数组下标关系](https://i.loli.net/2020/08/08/kMHgLvqNm78A42Y.png)

* #### 代码

  ```cpp
  #include <iostream>
  #include <cstdio>
  #include <cstring>
  #include <algorithm>
  using namespace std;
  #define N 500005
  int valu[27];
  int sum[N];   //下标从1开始
  char str[N];
  char new_str[2*N];
  int p[2*N];
  int Manacher(char* str);
  int main()
  {
      int t;
      scanf("%d",&t);
      int ans = 0;
      for(int i = 1;i <= t;i ++)
      {
          ans = 0;
          int valusum = 0;
          for(int j = 1;j <= 26;j ++)
          {
              scanf("%d",&valu[j]);
          }
          scanf("%s",str);
          Manacher(str);
          int lenstr = strlen(str);
          sum[0] = 0;
          for(int j = 0;j < lenstr;j ++)
          {
              int num = str[j];
              sum[j+1] = sum[j]+valu[num-96];
          }
          for(int j = 0;j < lenstr - 1;j ++)
          {
              valusum = 0;
              if(p[j+2]+j+2==2*j+4)
              {
                  valusum += (sum[j+1]-sum[0]);  //关系如上图
              }
              if(p[j+lenstr+2]+j+lenstr+2==2*lenstr+2)
              {
                  valusum += (sum[lenstr] - sum[j+1]);
              }
              ans = max(ans,valusum);
          }
          printf("%d\n",ans);
      }
      return 0;
  }
  int Manacher(char* str)
  {
      memset(p,0,sizeof(p));
      int lenstr = strlen(str);
      new_str[0] = '$';
      for(int i = 0;i < lenstr;i ++)
      {
          new_str[i*2+1] = '#';
          new_str[i*2+2] = str[i];
      }
      new_str[lenstr*2+1] = '#';
      new_str[lenstr*2+2] = '\0';
      int mx = 0,id;
      int ans = 0;
      int lennewstr = strlen(new_str);
      for(int i = 1;i < lennewstr;i ++)
      {
          if(mx>i)
          {
              p[i] = min(mx-i,p[id*2-i]);
          }else
          {
              p[i] = 1;
          }
          while(new_str[i-p[i]]==new_str[i+p[i]])
          {
              p[i]++;
          }
          if(i+p[i]>mx)
          {
              mx = p[i] + i;
              id = i;
          }
          ans = max(ans,p[i]);
      }
      return ans - 1;
  }
                          
  ```

  

