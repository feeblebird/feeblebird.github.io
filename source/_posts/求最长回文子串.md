---
title: 求最长回文子串
date: 2020-08-07 16:15:11
tags:
	- Manacher算法
	- 马拉车算法
	- 最长回文子串
	- 有符号类型和无符号类型数值比较陷阱
categories: 最长回文子串s
---
# 最长回文子串
  回文串就是一个正读和反读都一样的字符串，比如“level”或者“noon”等等就是回文串。回文子串，顾名思义，即字符串中满足回文性质的子串。比如输入字符串 "google”，由于该字符串里最长的对称子字符串是 "goog”，因此最长回文子串的长度为4。
# 使用Manachaer算法求最长回文子串

* 给出一个字符串，要求计算出这一字符串的最长回文子串的长度。如果遍历每一个字符，并以该字符为中心向两边查找，则其时间复杂度为O(*n*<sup>2</sup>)。

* Manacher算法又被称为“马拉车”算法，可以在时间复杂度为O(n)的情况下求解一个字符串的最长回文子串的长度。

* #### Manacher算法对字符串的预处理

  * 由于回文分为偶回文（例如"bccb"）和奇回文（例如"bcacb"），而在处理奇偶问题上会比较繁琐，例如，对于偶回文"bccb"，其对称重心是在两个'c'字符之间；对于奇回文"bcacb"，对称中心就是'a'字符。

  * 对此，Manacher算法在字符串首尾，及各字符间各插入一个字符，而这个字符并未出现在字符串里。例如，字符串s是"abbahopxpo"，用未出现在字符串里的'#'字符插入，得新字符串s_new是"\$#a#b#b#a#h#o#p#x#p#o"，其中，'$'是为了防止越界。在字符串S中，有一个偶回文"abba"和一个奇回文"opxpo"，分别被转换成"#a#b#b#a#"和"#o#p#x#p#o#"，回文的`长度都成了奇数` 。

    ![对字符串的预处理](https://i.loli.net/2020/08/07/3cUyC5PLBGQvzFq.png)

* #### 求解p[]数组

  * 通过预处理之后，可以统一处理奇回文字符串和偶回文字符串
  * 所以接下来要做的就是求出p[]

![求解p思路](https://i.loli.net/2020/08/07/j76WIBYFX34EUMu.png)

  


# Palindrome (POJ 3974)

* #### 题目简略概括：:articulated_lorry:

  想要求一个字符串的最长回文子串的长度，用一种比遍历更好的方法进行求解。

* #### 输入

  您的程序将对最多达30个的测试用例进行测试，每个测试用例在 一行中以最多1000000个小写字符的字符串形式给出。输入以字符串"END"开头的一行结束（为了清楚起见，用引号）

* #### 输出

  对于输入中的每个测试用例，输出测试用例编号和最长回文子串的长度

* #### 分析

  这是一道裸的用Manacher算法的题目

* #### 代码

  ```cpp
  #include <iostream>
  #include <cstring>
  #include <cstdio>
  using namespace std;
  #define N 1000005*2
  int p[N];
  char new_str[N];
  char str[N];
  int Manacher(char* str);
  int main()
  {
      int ind = 1,ans;
      while(scanf("%s",str)!=EOF)
      {
          if(str[0]=='E')
          {
              break;
          }
          ans = Manacher(str);
          printf("Case %d: %d\n",ind,ans);
          ind++;
      }
      return 0;
  }
  int Manacher(char* str)
  {
      int ans = 0;
      int lenstr = strlen(str);
      new_str[0] = '$';
      for(int i = 0;i < lenstr;i ++)//以后要特别注意无符号数和有符号数之间数值比较，因为编译器会把有符号数转换成无符号数，所以比如这个例子，int就会转换成无符号数，如果过int符号位为1，那么就会变得很大，程序就会出错，从这道题的经历来看，就会死循环
      {
          new_str[2*i+1] = '#';
          new_str[2*i+2] = str[i];
      }
      new_str[lenstr*2+1] = '#';
      new_str[lenstr*2+2] = '\0';
      int id = 0,mx = 0;
      int lennewstr = strlen(new_str);
      for(int i = 1;i < lennewstr;i ++)//以后要特别注意无符号数和有符号数之间数值比较
      {
          if(mx>i)
          {
              p[i] = min(mx-i,p[2*id-i]);
          }else
          {
              p[i] = 1;
          }
          while(new_str[i-p[i]]==new_str[i+p[i]])
          {
              p[i]++;
        }
          if(p[i]+i>mx)
          {
              mx = p[i] + i;
              id = i;
          }
          ans = max(ans,p[i]);
      }
      return ans-1;
  }
  
  ```
  
  > ~~血泪教训！！！~~ 这个题看了半天都是超时，自己改了半天实在想不通到底那里还能再节省时间，结果。。。，结果。。。，就是for循环里面strlen(str)和int的比较搞得鬼。和网上的博客对照了半天，实在没改的了试着改了这个，结果就过了。

# 要注意无符号数和有符号数直接比较的问题

* 上网查了一下，上面这个题超时的原因就是size_t类型是无符号整型，在和int比较的时候，因为编译器会将小的类型转换成大的类型，所以会把int转换成无符号数，而如果int的符号位是1之类的，那么就会转换成一个特别大的数，程序就会出错。

* 当然，出错的原因不仅仅这个，具体编程什么样子应该是不可控制的。

* ## 所以以后再用sizeof()和strlen()函数的时候，先用一个有符号变量进行强转一下。

# Best Reward (HDOJ 3613)

