---
title: 哥德巴赫猜想及其扩展
date: 2020-08-04 20:00:56
tags:
	- 哥德巴赫猜想
	- 素数筛选
categories: 数论
---
# 哥德巴赫猜想：(Goldbach's Conjecture)
* 每个大于4的偶数可以写成两个奇素数的和。

* 现在哥德巴赫猜想任然没有被证明是否正确。现在请您证明对所有小于一百万的偶数，哥德巴赫猜想成立。

* #### 输入 

  输入包含一个或多个测试用例。每个测试用例给出一个偶整数*n*，6≤*n*<1000000。输入以0结束。

* #### 输出

  对每个测试用例，输出形式为*n* = *a* + *b*的一行，其中*a*和*b*是奇素数，数字和操作符要用一个空格分开，如样例输出所示。如果有多于一对的奇素数的和加起来为*n*，就选择b - a最大的一对。如果没有这样的对，输出"Goldbach's conjecture is wrong."。

* #### 分析

  先筛选出所有的素数，然后从小到大开始，n - a 如果也是个素数，则满足，且第一个满足这个关系的就是b - a最大的一对。

* #### 代码
```cpp
#include <iostream>
#include <algorithm>
using namespace std;
#define N 1000000
bool u[N+5];
int prime[N];
int num = 0;
void judge(int k);
int main()
{
    for(int i = 2;i <= N;i ++)
    {
        u[i] = true;
    }
    for(int i = 2;i <= N;i ++)
    {
        if(u[i])
        {
            prime[++num] = i;
        }
        for(int j = 1;j < num;j ++)
        {
            if(i*prime[j] > n)
            {
                break;
            }
            u[i*prime[j]] = false;
            if(i%prime[j]==0)
            {
                break;
            }
        }
    }
    while(true)
    {
        int k;
        cin>>k;
        if(k==0)
        {
            break;
        }
        judge(k);
    }
    return 0;
}
void judge(int k)
{
    for(int i = 1;i < num;i ++)
    {
        if(prime[i]>=k)
        {
            cout<<"Goldbach's conjecture is wrong."<<endl;
            break;
        }
        int tem = k - prime[i];
        bool tru = binary_search(prime+1,prime+num+1,tem); //用stl二分查找
        if(tru)
        {
            cout<<k<<" = "<<prime[i]<<" + "<<tem<<endl;
            return;
        }
    }
}
```
# 哥德巴赫猜想的扩展(Summation of Four Primes)

* Euler证明的经典定理之一是素数在数量上是无限的。但每个数字是否可以表示成4个 素数的总和？我不知道答案，请您来帮我。

* #### 输入

  在输入的每行中给出一个整数*N* (*N*≤10000000)，请您将这一整数表示为4个素数的总和。输入以EOF为结束。(ctrl+z/b)

* #### 输出

  对于输入的每行，给出4个素数的一行输出。如果给出的数字不能表示为4个素数的总和，则输出

  一行“Impossible.”。存在多个解的情况，任何成立的解答都会被接受。

* #### 分析

  我们知道哥德巴赫猜想是一个大于4的偶数可以写成两个素数的和。我们可以这样处理：

* 对于偶数，我们假定第一第二个素数都为2，则偶数-4之后的数根据哥德巴赫猜想拆分。

* 对于奇数，我们假定第一个素数为2，第二个素数为3，则奇数-5之后为偶数，根据哥德巴赫猜想拆分。

这就要求数字必须大于等于8，8一下的数没有办法拆分成4个素数的和。

* #### 代码

```cpp
#include <iostream>
#include <algorithm>
using namespace std;
#define N 10000000
bool u[N+5];
int prime[N];
int num = 0;
void judge(int k,int flag);
int main()
{
    for(int i = 2;i <= N;i ++)
    {
        u[i] = true;
    }
    for(int i = 2;i <= N;i ++)
    {
        if(u[i])
        {
            prime[++num] = i;
        }
        for(int j = 1;j <= num;j ++)
        {
            if(i*prime[j]>N)
            {
                break;
            }
            u[i*prime[j]] = false;
            if(i%prime[j]==0)
            {
                break;
            }
        }
    }
    int k;
    while(cin>>k)
    {
        if(k<8)
        {
            cout<<"Impossible"<<endl;
        }else
        {
            if(k%2==0)
            {
                k -= 4;
                judge(k,1);
            }else
            {
                k -= 5;
                judge(k,0);
            }
        }
    }
    return 0;
}
void judge(int k,int flag)
{
    for(int i = 1;i < num;i ++)
    {
        int tem = k - prime[i];
        bool tru = binary_search(prime+1,prime+num+1,tem);
        if(tru)
        {
            if(flag==1)
            {
                cout<<"2 2 "<<prime[i]<<' '<<tem<<endl;
                return;
            }else
            {
                cout<<"2 3 "<<prime[i]<<' '<<tem<<endl;
                return;
            }
        }
    }
}
```

