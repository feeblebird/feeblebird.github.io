---
title: 不定方程
date: 2020-08-05 16:54:51
tags:
	- 最大公约数
	- 不定方程
	- 扩展欧几里得
categories: 数论
---
# 一些定义及定理

* #### 0没有约数，1的约数是它自己

* #### 一般说的约数都是正的

* #### 线性组合

  如果*a*和*b*都是整数，则*ax*+*by*是*a*和*b*的线性组合，其中数*x*和*y*是整数

* #### GCD(a,b)是a,b的线性组合中最小的正整数

  如果*a*和*b*都是整数，且`a和b不全为0` ，则*GCD*(*a*, *b*) 是*a*和*b*的线性组合中最小`正整数` 。

  > 注意这是最小正整数，意思是线性组合生成的正整数中它是最小的。可能有零

  * ###### 证明

    ![证明](https://i.loli.net/2020/08/05/s186KGAtj9H52QM.png)
    
    > 上面这个过程证明了a，b的最大公约数是a，b线性组合中最小的正整数，所以对于a,b的其他公约数来说，a,b的线性组合就无解了。

* #### Bezout定理

  如果整数a和b有最大公因数GCD(a,b)，那么则有整数x和y使得ax+by = GCD(a,b)

  * ##### 推论

    整数a和b互素当且仅当存在整数x和y使得ax+by =1
    

# 扩展欧几里得算法求不定方程的一个解
* #### 给出不定方程ax+by = GCD(a,b)，其中的a和b是整数

  ![求解思路](https://i.loli.net/2020/08/05/QrjIc3b7EqxieJm.png)

  > 推到最后的时候，y<sub> n</sub>可以不为零，但是回代的时候代零方便

* #### 扩展欧几里得算法，既可以求不定方程的解，还可以求最大公约数

```cpp
int excgcd(int a,int b,int &x,int &y) //x,y为不定方程的解
{
    if(b==0)
    {
        x = 1;
        y = 0;   //这里可以为任意整数，经过程序验证是正确的
        return a;
    }
    if(a<b)
    {
     	int t = a;
        a = b;
        b = t;
    }
    int r = a % b;
    int ans = excgcd(b,r,x,y);
    int ox = x;
    int oy = y;
    x = oy;
    y = ox - (a/b)*oy;
    return ans; //返回最大公约数
}
```

> ~~之前证明过a,b的所有因数就是b和a mod b的所有的因数，所以对于所有的因数来说，都可以用扩展欧几里得算法来计算出不定方程的解。~~ 这里不是，因为之前证明过GCD(a,b)是a,b线性组合中最小正整数，而它又是最大公因数，所以其它的公因数不能用a,b的线性组合来表示。
>
> 下面即将介绍到，如果ax + by = c; c如果是GCD(a,b)的整数倍，那么该方程就有无数解，如果不是GCD(a,b)的整数倍，则方程无解。

# 不定方程的通解

* 设*a*, *b*和*c*都是整数。如果*c*不是*GCD*(*a*, *b*)的倍数（整数倍），则不定方程*ax*+*by*=*c*没有整数解；如果*c*是*GCD*(*a*, *b*)的倍数，则不定方程*ax*+*by*=*c*有无穷多整数解。如果(*x*<sub>0</sub>  , *y*<sub>0</sub>)是*ax*+*by*=*c*的一个整数解，则*ax*+*by*=*c*的所有整数解是*x*= *x*<sub>0</sub>\+ *k* (*b* DIV *GCD*(*a*, *b*))，*y*= *y*<sub>0</sub>\-*k* *(*a*DIV *GCD*(*a*, *b*))，其中*k*是整数。

* #### 证明

  ![](https://i.loli.net/2020/08/05/STIjomOKGXYwRsb.png)
  
# 扩展欧几里得求不定方程的通解

* ### 方式一（直接倍数关系）

  ![](https://i.loli.net/2020/08/05/STIjomOKGXYwRsb.png)

  * 即直接计算ax + by = GCD(a,b)的解，然后直接倍数关系就是ax + by = c 的解。通解的话，只是对于本方程来说的，步骤就是先找出一个本方程的解，然后套公式就行，不用求出ax + by = GCD(a,b)的通解。

* ### 方式二（利用 GCD(a/GCD(a,b),b/GCD(a,b)) = 1）

  ![](https://i.loli.net/2020/08/06/uUE9fg6xKSTmwin.png)

  ![](https://i.loli.net/2020/08/06/e72sQI4ofdrSWAN.png)
  
  > 上面那个正是因为GCD(a,b)是a,b的公约数，才能除。如果直接给一个不定方程，如果有解的话，则说明该数是GCD(a,b)的倍数。可以除以GCD(a,b)，得到a'x + b'y = d'，然后此时GCD(a',b') = 1，所以利用a'x + b'y = 1 来求出一个根(x<sub>0</sub>，y<sub>0</sub>)，则a'x+b'y = d'的根就为(d'x<sub>0</sub>,d'y<sub>0</sub>)。a'x + b'y = d' 和 ax + by = d 是倍数关系，所以这个根也就是ax + by = d 的根。
  >
  > > 但是这里的这个通解我没太看懂，为啥不是套的公式，套公式的解包含这个通解。


# The balance (POJ 2142)

* #### 题目

  Iyo Kiffa Australis女士有一个天平，但只有两种砝码可以用来称量 一剂药物。例如，用300毫克和700毫克的砝码来测量200毫克阿司匹林，她就要将1个700毫克的砝码和药物放在天平的

  一边，并将3个300毫克的砝码放在天平的另一边，如图1所示。虽然她也可以将4个300毫克的砝码放和药物放在天平的一边，两个700毫克的砝码放在天平的另一边，如图2所示，但她不会选择这个方案，因为使用更多的砝码不太方便。

![](https://i.loli.net/2020/08/06/Osie46z1dwnvbox.png)

![](https://i.loli.net/2020/08/06/dw4csK9QMZoPq7D.png)

​		请您帮助Iyo Kiffa Australis女士，帮她计算要用多少的砝码。

* #### 输入

  输入是一系列的测试用例。每个测试用例一行，给出3个用空格分隔的正整数*a*, *b*和*d*，并满足以下关系：a$\neq$b，*a*$\leq$10000， *b*$\leq$10000，而且*d*$\leq$50000。本题设定，您可以使用*a*毫克和*b*毫克的砝码组合来称量*d*毫克；也就是说，您不需要考虑“无解”的情况。

  输入结束由一行表示，该行给出3个由空格分隔的零。这一行不是测试用例。

* #### 输出

  输出由一系列的行组成，每行对应一个测试用例(*a*, *b*, *d*)。一个输出行给出两个由空格分隔的非负整数*x*和*y*，且*x*和*y*要满足以下三个条件： 

  * 使用*x*个*a*毫克的砝码和*y*个*b*毫克的砝码可以称量*d*毫克。

  * 在满足上述条件的非负整数对中，砝码总数(*x + y*)最小。

  * 在满足前两个条件的非负整数对中，砝码的总的质量(*ax + by*)最小。

  * 输出中不能出现额外的字符（例如，额外的空格）。

* #### 分析

  ![要求|x|+|y|最小](https://i.loli.net/2020/08/06/ILMRDBOkHZPvo2U.png)

  然后第三个要求直接枚举判断就可以了。

* #### 代码

```cpp
#include <iostream>
#include <cstdio>
#include <cmath>
using namespace std;
int excgcd(int a,int b,int &x,int &y);
int main()
{
    int a,b,d;
    int x0,y0,gcd;
    int x,y;
    bool flag = true;
    while(true)
    {
        flag = 1;  //记录是否交换
        scanf("%d%d%d",&a,&b,&d);
        if(a==0&&b==0&&d==0)
        {
            break;
        }
        if(a<b)
        {
            int t = a;
            a = b;
            b = t;
            flag = false;
        }
        gcd = excgcd(a,b,x0,y0);
        int bei = d /gcd;
        x0 = x0 * bei;
        y0 = y0 * bei;
        int k = y0/(a/gcd);  //如之前图的分析，在这个点附近会出现最小值
        int ansx = abs(x0 + k*(b/gcd)),ansy = abs(y0 - k*(a/gcd));
        int mi = ansx + ansy;
        for(int i = k-5;i <= k+5;i ++) //枚举十个点，选出最小的
        {
            int nansx = abs(x0 + i*(b/gcd)); //注意这里要保证a > b，所以直接就在前面交换了
            int nansy = abs(y0 - i*(a/gcd));
            int temp = abs(x0 + i*(b/gcd))+abs(y0 - i*(a/gcd));
            if(temp<mi)
            {
                mi = temp;
                ansx = nansx;
                ansy = nansy;
            }else if(temp == mi)
            {
                if(a<b)
                {
                    int we1 = b * ansx + a * ansy;
                    int we2 = b * nansx + a * nansy;
                    if(we1>we2)
                    {
                        ansx = nansx;
                        ansy = nansy;
                    }
                }else
                {
                    int we1 = a * ansx + b * ansy;
                    int we2 = a * nansx + b * nansy;
                    if(we1>we2)
                    {
                        ansx = nansx;
                        ansy = nansy;
                    }
                }
            }
        }
        if(flag)
        {
            printf("%d %d\n",ansx,ansy);
        }else
        {
            printf("%d %d\n",ansy,ansx);
        }
       
    }
    return 0;
}
int excgcd(int a,int b,int &x,int &y)
{
    if(b==0)
    {
        x = 1;
        y = 0;
        return a;
    }
    int ans = excgcd(b,a%b,x,y);
    int ox = x,oy = y;
    x = oy;
    y = ox - oy * (a / b);
    return ans;
}
```

> 相比与之前的那个扩展欧几里得，这个程序是直接在输入的时候就判断a,b的值是否要交换，因为后面的计算通解的时候要保证这一点，不然会出错

# One Person Game(ZOJ 3593)

* #### 题目描述

  有一个有趣而简单的单人游戏。假设在您脚下有一个数轴，开始时您在*A*点，您的目标是*B*点，您可以在一步内做6种动作之一，向左或向右行走*a*，*b*或*c*，其中*c*等于*a+b*。 您必须尽快到达*B*点。请您计算最小步数。

* #### 输入

  输入有多个测试用例。输入的第一行是一个整数*T*（0 < *T* $\leq$1000），表示测试用例的数量，然后给出*T*个测试用例。每个测试用例都由一个包含四个整数的行表示，4个用空格分隔整数*A*, *B*, *a*和*b*，（\-2<sup>31</sup>$\leq$*A*, *B* < 2<sup>31</sup>, 0 < *a*, *b* < 2<sup>31</sup>）

* #### 输出

  对于每个测试用例，输出最少步数。如果无法到达*B*点，则输出“-1”。

* #### 分析

  根据ax + by = |B - A|的解来做。

* #### 代码

```cpp
#include <iostream>
using namespace std;
bool flag = true;
int excgcd(int a,int b,int &x,int &y);
int main()
{
    if(a<b)
    {
        int t = a;
        a = b;
        b = t;
    }
    return 0;
}
int excgcd(int a,int b,int &x,int &y)
{
    if(b == 0)
    {
        x = 1;
        y = 0;
        return a;
    }
    int ans = excgcd(b,a%b,x,y);
    int ox = x,oy = y;
    x = oy;
    y = ox - oy*(a/b);
    return ans;
}
```

