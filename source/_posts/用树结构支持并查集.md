---
title: 用树结构支持并查集
date: 2020-08-12 08:05:51
tags:
	- 并查集
categories: 高级数据结构
---
# 并查集

* #### 定义

  在一些应用中，需要把n个不同元素划分成不相交的若干组，每 一组的元素构成

  一个集合，由于这类问题主要涉及对集合的合并和查找，因此称为并查集

* #### 并查集的三种操作

  * **Make_Set(x)**:加入一个含单元素x的集合{x}到并查集S，且rep[{x}] = x。
    * x不能被包含在任何一个S<sub>i</sub>中，因为S里任何两个集合是不相交的。
    * 初始时，对每个元素x执行一次Make_Set(x)。
  * **join(x,y)**:把x和y所在的两个不同集合S<sub>x</sub>和S<sub>y</sub>合并:从S中删除S<sub>x</sub>和S<sub>y</sub>，并加入S<sub>x</sub>和S<sub>y</sub>。
  * **set_find(x)**:返回x所在的集合S<sub>x</sub>的代表元rep[S<sub>x</sub>]。

# 并查集的表示

* 用链表表示

  每个集合用双向链表表示，代表元rep[S<sub>i</sub>]在链表的首部，集合中的每个节点除前后指针外，增加一个指向代表元rep[S<sub>i</sub>]的指针，如图：

  ![](https://i.loli.net/2020/08/12/tWNrLE7MGvzXqUT.png)

* 用树结构表示

  每个集合用一颗树表示，根为集合的代表元。每个节点p设一个指针set[p]，记录它所在树的根节点序号。如果set[p]<0，则表明p为根节点。初始时，为每个元素建立一个集合，即set[x]=-1(1$\leq$x$\leq$n)。

  ![](https://i.loli.net/2020/08/12/DEQYqRNCGd5M8rZ.png)

# 树结构的查找操作set_find(x)

* #### 边查找边路径压缩

  * 首先，从节点x出发，沿set指针查找节点x所在树的根节点f（set[f]<0）。

  * 然后，进行路径压缩，将x至f的路径上经过的每个节点的set指针都指向f。

    ![](https://i.loli.net/2020/08/12/JhMw8D3HpjRSCQy.png)

```cpp
int set_find(int p)
{
    if(set[p] == p)
    {
        return p;
    }
    return set[p] = set_find(set[p]);
}
```
* #### 路径压缩的目的

  是为了当大多数节点的父亲直接就是根，这样再去查询的时候就会很快了。并查集对每个集合内部的具体结构没有要求，所以就可以修改树的结构。

# 并查集更通俗的解释

  话说江湖上散落着各式各样的大侠，有上千个之多。他们没有什么正当职业，整天背着剑在外面走来走去，碰到和自己不是一路人的，就免不了要打一架。但大侠们有一个长处就是讲义气，绝对不打自己的朋友，并且他们信奉“朋友的朋友就是我的朋友”。仅仅要是能通过朋友关系串联起来的。不管拐了多少个弯，都觉得是自己人。这样一来，江湖上就形成了一个一个的群落。通过两两之间的朋友关系串联起来。

  而不在同一个群落的人，不管怎样都无法通过朋友关系连起来。于是就能够放心往死了打。可是两个原本互不相识的人。怎样推断是否属于一个朋友圈呢？

  我们能够在每一个朋友圈内推举出一个比較有名望的人，作为该圈子的代表人物。这样，每一个圈子就能够这样命名“齐达内朋友之队”“罗纳尔多朋友之队“······两人仅仅要互相对一下自己的队长是不是同一个人，就能够确定敌友关系了。

  可是还有问题啊，大侠们仅仅知道自己直接的朋友是谁，非常多人压根就不认识队长，要推断自己的队长是谁。仅能通过朋友的朋友关系问下去：“你是不是队长？你是不是队长？”。这样一来，队长面子上挂不住了，并且效率太低，还有可能陷入无限循环中。

于是队长下令，又一次组队。队内全部人实行分等级制度，形成树状结构，我队长就是根节点，以下各自是二级队员、三级队员。

每一个人仅仅要记住自己的上级是谁即可了。遇到推断敌友的时候。仅仅要一层层向上问。直到最高层，就能够在短时间内确定队长是谁了。因为我们关心的仅仅是两个人之间是否连通，至于他们是如何连通的，以及每一个圈子内部的结构是如何的。甚至队长是谁，并不重要。所以我们能够放任队长任意又一次组队，仅仅要不搞错敌友关系就好了。于是，门派产生了。

  建立门派的过程是用merge函数两个人两个人地连接起来的，谁当谁的手下全然随机。最后的树状结构会变成什么样也全然无法估计。一字长蛇阵也有可能。这样查找的效率就会比较低下。最理想的情况就是全部人的直接上级都是掌门，一共就两级结构，仅仅要找一次就找到掌门了。

  哪怕不能全然做到，也最好尽量接近。

  这样就产生了路径压缩算法。

  设想这样一个场景：两个互不相识的大侠碰面了，想知道能不能揍。 于是赶紧打电话问自己的上级：“你是不是掌门？” 上级说：“我不是呀，我的上级是谁谁谁。你问问他看看。” 一路问下去。原来两人的终于boss都是东厂曹公公。 “哎呀呀，原来是自己人，失礼失礼，在下三营六组白面葫芦娃!” “幸会幸会，在下九营十八组狗尾巴花仙子！

” 两人高高兴兴地手拉手喝酒去了。 “等等等等。两位大侠请留步，还有事情没完毕呢！

“哦，对了，还要做路径压缩。”两人醒悟。

白面葫芦娃打电话给他的上级六组长：“组长啊。我查过了。其习我们的掌门是曹公公。

不如我们一起直接拜在曹公公手下吧。省得以后查找掌门麻环。

” ，“唔。有道理。” 白面葫芦娃接着打电话给刚才拜访过的三营长……仙子狗尾巴花也做了相同的事情。

这样，查询中全部涉及到的人物都聚集在曹公公的直接领导下。每次查询都做了优化处理，所以整个门派树的层数都会维持在比较低的水平上。

# 树结构合并操作join(x,y)

* #### 将两棵树的根节点相连

  计算x元素所在并查集的树根fx和y元素所在并查集的树根fy。如果fx == fy，则说明元素x和元素y在同一并查集中；否则将x所在的元素并入y所在的集合，也就是将fx的set指针设为fy。

  ![image.png](https://i.loli.net/2020/08/12/b4oxLvErKTwuQmO.png)

```cpp
void join(int p,int q)
{
    p = set_find(p);
    q = set_find(q);
    if(p!=q)
    {
        set[p] = q;
    }
}
```

# Find them,Catch them(POJ 1703)

* #### 题目描述

  * Tadu市的警察局决定结束混乱，因此要采取行动，根除城市中的两大帮派：龙帮和蛇帮。然而，警方首先需要确定某个罪犯是属于哪个帮派。目前的问题是，给出两个罪犯，他们是属于同一个帮派吗？您要基于不完全的信息给出您的判断，因为歹徒总是在暗中行事。
  * 假设在Tadu市现在有N（N≤10<sup>5</sup>）个罪犯，编号从1到N。当然，至少有 一个罪犯属于龙帮，也至少有一个罪犯属于蛇帮。给出M（M≤10<sup>5</sup>）条消息组成的序列，消息有下列两种形式：
  * 1.D\[a\]\[b\]
  * 其中\[a\]和\[b\]是两个犯罪分子的编号，他们属于不同的帮派；
  * 2.A\[a\]\[b\]
  * 其中\[a\]\[b\]是两个犯罪分子的编号，您要确定a和b是否属于同一帮派。

* #### 输入

  输入的第一行给出给出一个整数T（1$\leq$T$\leq$20），表示测试用例的个数。后面跟着T个测试用，每个测试用例的第一行给出两个整数N和M，后面的M行每行给出一条如上面所描述的消息
  
* #### 输出

  对于在测试用例中的每条“A \[a\] \[b\]”消息，您的程序要基于此前给出的信息做出判断。回答是如下之一“In the same gang.”，“In different gangs.”或“Not sure yet.“
  
* #### 分析

  ![分析](https://i.loli.net/2020/08/13/zwHRODT5mZlByqb.png)

* #### 错误代码

```cpp
#include <stdio.h>
#include <string.h>
#define N 100005
#define N2 100001
int set[N];
int set_find(int x);
void set_join(int a,int b);
int main()
{
    
    set[N2] = N2;
    set[0] = 0;
    int t;
    char str[2];
    int n,m;
    int p1,p2;
    scanf("%d",&t);
    for(int i = 1;i <= t;i ++)
    {
        scanf("%d%d",&n,&m);
        for(int i = 1;i <= n;i ++)
        {
            set[i] = i;
        }
        for(int j = 1;j <= m;j ++)
        {
            scanf("%s",str);
            scanf("%d%d",&p1,&p2);
            int tem1 = set_find(p1);
            int tem2 = set_find(p2);
            if(!strcmp(str,"A"))
            {
                if(p1==p2)
                {
                    printf("In the same gang.\n");
                    continue;
                }
                if(tem1 ==p1 || tem2 == p2)
                {
                    printf("Not sure yet.\n");
                }else if(tem1 == tem2)
                {
                    printf("In the same gang.\n");
                }else
                {
                    printf("In different gangs.\n");
                }
            }else
            {
                if(tem1!=p1 || tem2!=p2)
                {
                    if(tem1==p1)
                    {
                        set_join(N2-tem2,p1);
                    }
                    if(tem2==54p2)
                    {
                        set_join(N2-tem1,p2);
                    }
                }else
                {
                    set_join(0,p1);
                    set_join(N2,p2);
                }
            }
        }
    }
    return 0;
}
int set_find(int x)
{
    if(set[x]==x)
    {
        return x;
    }
    return set[x] = set_find(set[x]);
}
void set_join(int a,int b)
{
    int fa = set_find(a);
    int fb = set_find(b);
    if(fa!=fb)
    {
        set[b] = a;
    }
}

```

* #### 错误原因

![错误原因](https://i.loli.net/2020/08/13/hrSeBFnzDkyW1Lc.png)

* #### 正确代码

```cpp
#include <iostream>
#include <cstring>
#include <cstdio>
using namespace std;
#define N 100005
int set[N*2+1];
char str[2];
int set_find(int x);
void set_join(int x,int y);
bool same(int x,int y);
int main()
{
    int t;
    scanf("%d",&t);
    int n,m,p1,p2;
    for(int i = 1;i <= t;i ++)
    {
        scanf("%d%d",&n,&m);
        for(int i = 0;i <= 2*n;i ++)
        {
            set[i] = i;
        }
        for(int j = 1;j <= m;j ++)
        {
            scanf("%s",str);
            scanf("%d%d",&p1,&p2);
            if(!strcmp(str,"A"))
            {
                if(same(p1,p2)||same(p1+n,p2+n))   //也可以只判断(same(p1,p2))
                {
                    printf("In the same gang.\n");
                }else if(same(p1+n,p2)||same(p1,p2+n))//也可以只判断(same(p1+n,p2))
                {
                    printf("In different gangs.\n");
                }else
                {
                    printf("Not sure yet.\n");
                }
            }else
            {
                set_join(p1+n,p2);
                set_join(p1,p2+n);
            }
        }
    }
    return 0;
}
int set_find(int x)
{
    if(set[x] == x)
    {
        return x;
    }
    return set[x] = set_find(set[x]);
}
void set_join(int x,int y)
{
    x = set_find(x);
    y = set_find(y);
    if(x!=y)
    {
        set[x] = y;
    }
}
bool same(int x,int y)
{
    int tem1 = set_find(x);
    int tem2 = set_find(y);
    return tem1==tem2;
}

```

# Cube Stacking(POJ 1988)

* #### 题目描述

  * 农夫John和Betsy在玩一个游戏，有*N*(1$\leq$*N*$\leq$30,000)块相同的立方，标记从1到*N*。开始时是*N*个栈，每个栈只有一个立方体。农夫John请Betsy执行*P*(1$\leq$*P*$\leq$100,000)个操作，有两类操作：move和count。
  * 在一个move操作中，农夫John请Bessy将包含立方体*X*的栈移到包含立方体*Y*的栈的栈顶。
  * 在一个count操作中，农夫John请Bessy计算包含立方体*X*的栈中在*X***下**的立方体个数，并返回值。
  * 请您编写一个程序返回游戏结果。

* #### 输入

  * 第1行：一个整数p
  * 第2..p+1行：每行给出一个合法的操作，第2行给出第一个操作，以此类推。每行开始时以'M'表示一个move操作，或以'C'表示一个count操作。对move操作，这一行还给出两个整数：x和y；对count操作，这一行给出一个整数：X。
  * 在输入文件中N的值不出现。Move操作不会要求一个栈移到它自己的上面。

* #### 输出

  按输入文件中的次序输出每一个count操作的结果。

* #### 题目分析

![分析](https://i.loli.net/2020/08/13/Y2WRsJkB4FziPmN.png)

* #### 代码

``` cpp
#include <iostream>
#include <cstdio>
#include <cstring>
using namespace std;
#define N 30004
int set[N];
int num[N];
int top[N];
int set_find(int x,int& ans);
void set_join(int x,int y);
int main()
{
    for(int i = 1;i <= N;i ++)
    {
        set[i] = i;  //栈底为自己
        top[i] = i;  //栈顶为自己
    }
    int p;
    scanf("%d",&p);
    char str[2];
    int p1,p2;
    for(int i = 1;i <= p;i ++)
    {
        scanf("%s",str);
        if(!strcmp(str,"M"))
        {
            scanf("%d%d",&p1,&p2);
            set_join(p1,p2);
        }else
        {
            int ans = 0;
            scanf("%d",&p1);
            set_find(p1,ans);
            printf("%d\n",ans);
        }
    }
    return 0;
}
int set_find(int x,int &ans) //ans是该元素下元素的个数
{
    if(set[x] == x)
    {
        ans += 0;
        return x;
    }
    set[x] = set_find(set[x],ans);//路径压缩
    ans += num[x]; //num数组是当前元素距离父节点的距离，根的num值为0
    num[x] = ans;  //路径压缩后更新num值
    return set[x];
}
void set_join(int x,int y)
{
    int ans = 0;
    x = set_find(x,ans);
    ans = 0;
    y = set_find(y,ans); //统一通过栈底来访问栈顶，所以先找到栈底，然后再获得y所在堆的高度。
    ans = 0;
    y = set_find(top[y],ans);
    if(x!=y)
    {
        set[x] = y;      //合并两个栈
        top[y] = top[x]; //修改y所在栈的栈顶
        num[x] = ans+1;  //修改x所在栈的栈底的num[]值为距离根的距离，也即距离父节点的距离
    }
}

```

# 食物链(POJ 1182)

* #### 题目描述

  * 动物王国中有三类动物A,B,C,这三类动物的食物链构成了有趣的环形：A吃B，B吃C，C吃A。
  * 现有N个动物，以1~N编号。每个动物都是A,B,C中的一种，但是我们并不直到它到底是哪一种。
  * 有人用两种说法对这N个动物所构成的食物链关系进行描述：
  * 第一种说法是"1 X Y"，表示X和Y是同类。
  * 第二种说法是"2 X Y"，表示X吃Y。
  * 此人对N个动物，用上述两种说法，一句接一句地说出K句话，这K句话有的是真的，有的是假的。当一句话满足下列三条之一时，这句话就是假话，否则就是真话。
  * 1) 当前的话与前面的某些真的话冲突，就是假话；
  * 2) 当前的话中X或Y比N大，就是假话；
  * 3) 当前的话表示X吃X，就是假话。
  * 你的任务是根据给定的N（1$\leq$N$\leq$50000）和K句话（0$\leq$K$\leq$100000），输出假话的总数。

* #### 输入

  * 第一行是两个整数N和K，以一个空格分隔。
  * 一下K行每行是三个正整数D，X，Y，两数之间用一个空格隔开，其中D表示说法的种类。
  * 若D = 1,则表示X和Y是同类。
  * 若D = 2,则表示X吃Y。

* #### 输出

  只有一个整数，表示假话的数目。

* #### 题目分析



* #### 代码

```cpp

```

