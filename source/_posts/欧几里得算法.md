---
title: 欧几里得算法
date: 2020-08-05 14:03:32
tags:
	- 欧几里得算法
	- 最大公约数
categories: 数论
---
# 欧几里得算法(辗转相除法)

* 用来计算两个负整数的最大公约数。

* 计算的公式为(a>b) GCD(a,b) = GCD(b,a mod b)

* #### 证明

  证明a 和 b 与 a 和 a mod b 的公约数是一样的。

  * 若 c 是 a 和 b 的公约数，则 c|a,c|b。而 a mod b = a - k\* b(k 为整数)。所以c|a mod b，c|b所以c也是 b 和 a mod b(a>b)的公约数。
  * 若 c 是 b 和 a mod b(a>b)的公约数，则 c|b,c|a mod b， a mod b = a - k\*b，因为k是整数且`c|b` ，所以c|a。所以c也是a 和 b 的公约数。

  所以GCD(a,b) == GCD(a,a mod b)（a>b）

> 上述直接证明了GCD(a,b) == GCD(b,a-k\*b)，如果按照这个推的话最后还是要走到a mod b这一步

* 所以依次类推下去：

  GCD(a,b) == GCD(b,a mod b) == GCD(a mod b, b mod (a mod b)) == ...... == GCD(m,0)

  则此时m 和 0 的最大公约数就是m了。也就求出了a 和 b的最大公约数。



# Happy 2006

* #### 题目描述

  如果两个正整数的最大公约数（Great Common Divisor，GCD）是1，则称这两个正整数是互素的。例如，1、3、5、7、9……和2006年都是互素的。

* #### 本题要求

  对于给出的整数*m*，找到按升序排列的第*K*个和*m*互素的整数

* #### 输入

  输入包含多个测试用例。每个测试用例给出两个整数m(1$\leq$m$\leq$1000000)和K(1$\leq$K$\leq$100000000)

* #### 输出

  在一行输出第k个和m互素的整数。

* #### 试题分析

  ![分析](https://i.loli.net/2020/08/05/wrdocCUJWHSNGfh.png)

  所以就先求出[1,a]区间中的与a互素的数。然后根据k的值进行周期选择。

* #### 代码

```cpp
#include <iostream>
using namespace std;
int p[1000005];
int num = 0;
int GCD(int a,int b);
int main()
{
    int k,m;
    while(scanf("%d%d",&m,&k)!=EOF)
    {
        num = 0;
        for(int i = 1;i <= m;i ++) //这里等于m是考虑m为1的情况
        {
            if(GCD(m,i)==1)
            {
                p[++num] = i;
            }
        }
        int mult = k / num;
        int modd = k % num;
        if(modd==0)
        {
            printf("%d\n",(mult-1)*m+p[num]);
        }else
        {
            printf("%d\n",mult*m+p[modd]);
        }
    }
    return 0;
}
int GCD(int a,int b)
{
    if(a==b){return a;}
    if(a<b)
    {
        int t = a;
        a = b;
        b = t;
    }  //让a>b
    while(b!=0)
    {
        int t = b;
        b = a % b;
        a = t;
    }
    return a;
}
```

> 这个题第一次用long long 怕溢出，结果就超时了。看网上说是因为虚拟机判题如果机器是32位的，则处理long long 就要用两个时间周期，而处理int只用一个时间周期。
>
> > 这个题还可以用容斥原理+二分来做，以后再来补上