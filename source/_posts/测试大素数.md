---
title: 测试大素数
date: 2020-08-04 21:53:42
tags: 
	- 测试素数
	- 试除法
	- 素数筛选
categories: 数论
katex: true
---
# 试除法

​	测试一个数n是否为素数，计算除2..$\lfloor \sqrt{n} \rfloor$ 的素数表，如果n是素数表中的一个素数或者n不能被素数表中的数整除，那么n就是素数。



# 测试大素数的实验范例

​	测试一个数是否为素数，最简便的方法是试除法，即试用2.. $\lfloor \sqrt{n} \rfloor$去除n。n是素数当且仅当没有一个试用的除数能被n整除。但是这个方法的时效取决于n。如果n很大则判断要花费很多时间。下面介绍两种优化算法：

* 筛选法+试除法
* Miller_Rabin方法

## 筛选法+试除法

   先通过筛选法计算[2,|$\sqrt{n}$|]的素数筛u[]和素数表prime[],素数表prime[]长度为num。x是素数当且仅当x为[2..|$\sqrt{n}$|]中的一个素数或者x不能被prime[]表中的任何素数整数。时间复杂度为O($\sqrt{n}$)。

> 如果直接用欧拉筛法的话，然后打表判断，复杂度为O(n)，如果n很大的话可能还是难以接受

## Primed Subsequence (UVA 10871)

* #### 描述
   给出一个长度为*n* 的正整数序列，一个素序列（Primed Subsequence）是一个长度至少为2 的连续的子序列，总和是大于或等于2的一个素数。例如给出序列：3 5 6 3 8，存在两个长度为2的素序列（5+6=11，以及3+8=11）、一个长度为3的素序列（6+3+8=17）和一个长度为4的素序列（3+5+6+3=17）。
   
* #### 输入

   输入包含若干测试用例。第一行给出一个整数*t*（1<*t*<21），表示测试用例的个数。每个测试用例

   一行。在这一行首先给出一个整数*n*，0< *n*< 10001；然后给出*n*个小于10000的非负整数，构成一个序列。 80%测试用例序列中最多有1000个数字。

* #### 输出

  对每个序列，输出“Shortest primed subsequence is length *x*:”，其中*x*是最短的素序列的长度，然后给出最短素序列，用空格分开。如果操作多个这样的序列，输出第一个出现的序列。如果没

  有这样的序列，输出“This sequence is anti\-primed.”

* #### 分析

  每个测试用例最多有10000个数字，每个数字小于10000，所以序列和最大为100000000，如果直接欧拉筛法的话，时间可能顶不住，此时就用筛选法+试除法把复杂度降低到10000。先离线计算出[2,10010]中的素数表，然后对于素数序列的和的计算，我们用前缀和数组来计算。

  > 因为要求最短序列和，所以不能直接二重遍历，要枚举长度，这样就能保证找到素序列后一定为最短的。

* #### 代码

```cpp
#include <iostream>
#include <cstdio>
#include <algorithm>
using namespace std;
#define N 10010
int prime[N];
bool u[N+5];
int num = 0;
int he[10005];
int yuan[10005];
void judge(int k);
int main()
{
    for(int i = 2;i <= N;i ++)
    {
        u[i] = true;
    }
    for(int i = 2;i <= N;i ++)
    {
        if(u[i])
        {
            prime[++num] = i;
        }
        for(int j = 1;j <= num;j ++)
        {
            if(i*prime[j]>N)
            {
                break;
            }
            u[i*prime[j]] = false;
            if(i%prime[j]==0)
            {
                break;
            }
        }
    }
    int t,k;
    scanf("%d",&t);
    for(int i = 0;i < t;i ++)
    {
        scanf("%d",&k);
        judge(k);
    }
    return 0;
}
void judge(int k)
{
    for(int j = 1;j <= k;j ++)
    {
        scanf("%d",&yuan[j]);
        
        he[j] = he[j-1] + yuan[j];
    }
    for(int m = 2;m <= k;m ++)         //枚举长度，找到后即为第一个
    {
        for(int j = 0;j <= k-m;j ++)
        {
            int ans = he[j+m]-he[j];
            if(binary_search(prime+1,prime+num+1,ans)) //如果就在素数表中，则输出
            {
				printf("Shortest primed subsequence is length %d:",m);
                for(int mm = j+1;mm <= j+m;mm ++)
                {
                    printf(" %d",yuan[mm]);
                }
                printf("\n");
                return;
            }else
            {
                bool flag = true;
                for(int mm = 1;mm <= num;mm ++)
                {
                    if(ans%prime[mm]==0)
                    {
                        flag = false;
                    }
                }
                if(flag)
                {
                    printf("%d",m);
                    for(int mm = j+1;mm <= j+m;mm ++)
                    {
                        printf(" %d",yuan[mm]);
                    }
                    printf("\n");
                	return;
                }
            }
        }
    }
    printf("This sequence is anti-primed.\n");
}
```



