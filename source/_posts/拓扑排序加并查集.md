---
title: 拓扑排序加并查集
date: 2020-09-12 12:29:03
tags:
	- 拓扑排序
	- 并查集
categories: 图论
---

# 拓扑排序

之前学过的

#### 代码如下

```cpp
#include <iostream>
#include <cstdio>
#include <queue>
#include <vector>
using namespace std;
#define MAX 250000
vector<int> head[MAX],ans; //用邻接矩阵存储图
priority_queue<int,vector<int>,greater<int> > q; //选择入度为零的点时用优先级队列，小根堆
int n,m,in[MAX];

int main()
{
    int n,m;
    scanf("%d%d",&n,&m);
    int l,k;
    for(int i = 1;i <= m; i++)
    {
        scanf("%d%d",&l,&k);
        head[l].push_back(k);
        in[k]++;
    }
    for(int i = 1;i <= n;i ++)
    {
        if(in[i]==0)
        {
            q.push(i);  //选择入读为零的点
        }
    }
    int len = ans.size();
    while(!q.empty() && len<n)
    {
        int v = q.top();
        q.pop();
        ans.push_back(v);
        int tem = head[v].size();
        for(int i = 0;i < tem;i ++)
        {
            in[head[v][i]]--; //删边
            if(in[head[v][i]]==0)
            {
                q.push(head[v][i]);
            }
        }
        len = ans.size();
    }
    if(len == n)
    {
        printf("yes");
    }else
    {
        printf("no");
    }
    return 0;
}

```





# Chess Tournament(并查集+拓扑排序)

#### 题目大意

* 给出 *N* 个选手的 *M* 种实力大小关系，问是否矛盾。N(2 $\leq$ N $\leq$ 50000)，M(1 $\leq$ M $\leq$ 250000)

#### 解题思路

* 若A < B，连一条从B到A的边
* 若A > B，连一条从A到B的边
* 若A = B，将A和B缩为一点
* 将M种关系放到有向图上，判断图种是否有环存在。缩点用并查集实现，判环可以用拓扑排序实现。

> 是先将等于关系的元素建立号并查集关系，然后将元素个数更新，同一并查集的点就当作一个点，然后对于某个具体元素的操作都是对其并查集根的操作。

#### 代码

```cpp
#include <iostream>
#include <cstdio>
#include <queue>
#include <vector>
using namespace std;
#define MAX 50002
vector<int> head[MAX],ans;//用vector二维数组存放这个图
priority_queue<int,vector<int>,greater<int> > p;
int set[MAX];
int in[MAX];
int set_find(int a);
void set_join(int a,int b);
int l[250005],k[250005],c[250004];
bool vis[MAX];
int main()
{
    int n,m;
    scanf("%d%d",&n,&m);
    int an = 0;
    for(int i = 0;i < n;i ++)
    {
        set[i] = i;
    }
    for(int i = 0;i < n;i ++)
    {
        vis[i] = false;
    }
    for(int i = 1;i <= m;i ++)
    {
        scanf("%d",&k[i]);
        c[i] = getchar();
        c[i] = getchar();
        scanf("%d",&l[i]);
        if(c[i]=='=')
        {
            set_join(k[i],l[i]);//将相等关系的点建立并查集
        }
    }
    for(int i = 1;i <= m;i ++)
    {
        int tem;
        if(c[i] == '>')
        {
            tem = set_find(l[i]);
            head[set_find(k[i])].push_back(tem);//直接对根操作，生成图
            in[tem]++;
        }else if(c[i] == '<')
        {
            tem = set_find(k[i]);
            head[set_find(l[i])].push_back(tem);//直接对根操作，生成图
            in[tem]++;
        }
    }
    for(int i = 0;i < n;i ++)
    {
        if(in[set_find(i)] ==0)
        {
            vis[set_find(i)] = true;
        }
    }
    for(int i = 0;i < n;i ++)
    {
        if(vis[i])
        {
            p.push(i);
        }
        if(set[i] == i)
        {
            an++;
        }
    }
    int len = ans.size();
    while(!p.empty() && len<n)
    {
        int v = p.top();
        p.pop();
        ans.push_back(v);
        int tem = head[v].size();
        for(int i = 0;i < tem;i ++)
        {
            int tem1 = set_find(head[v][i]);
            in[tem1]--;
            if(in[tem1] == 0)
            {
                p.push(tem1);
            }
        }
        len = ans.size();
    }
    //printf("%d   %d",len,an);
    if(len == an)
    {
        printf("consistent");
    }else
    {
        printf("inconsistent");
    }
    return 0;
}
int set_find(int a)
{
    if(set[a] == a)
    {
        return a;
    }
    return set[a] = set_find(set[a]);
}
void set_join(int a,int b)
{
    a = set_find(a);
    b = set_find(b);
    if(a != b)
    {
        set[a] = b;
    }
}

```

