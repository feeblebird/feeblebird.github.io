---
title: 同余方程和同余方程组
date: 2020-09-03 15:44:21
tags: 
	- 同余方程
	- 快速幂
categories: 数论
---

# 同余的定义和性质

* 给出一个正整数m和两个整数a和b，如果((a-b) mod m) = 0，则称a和b模m同余，记为a≡b(mod m)。如果((a-b) mod m) $\neq$ 0，则称a模m不同余于b。

* 例如，-7≡-3≡1≡5≡9(mod 4)，-5≡-1≡3≡7≡11(mod 4)，而7模5不同余于8。

* #### 定理1

  * 给出一个正整数m和两个整数a和b，((a-b) mod m) = 0当且仅当存在**整数k**，a = b + km。

* #### 定理2

  * 在一个同余式两边同时做加法、减法或**乘法**，依然保持同余。

  * 给出一个正整数m和三个整数a,b和c，a≡b(mod m)。则
    * a + c ≡ b + c (mod m);
    * a - c ≡ b - c (mod m);
    * ac ≡ bc (mod m)。

  ![证明](https://i.loli.net/2020/09/05/vohS8kqJ7NxOmnD.png)

  * 在一个同余式两边同时除以一个整数并不一定保持同余。例如，10 ≡ 4 (mod 6)，但如果两边同时除以2，就不能保持同余。

* #### 定理3    利用c,m的最大公约数

  * 给出一个正整数m和三个整数a，b和c，d = GCD(c,m),并且ac≡bc(mod m)。则a≡b(mod (m DIV d))。2
  * 证明：如果ac≡bc(m+od m)，则c(a-b) mod m = 0，即存在**整数k**，使得c(a-b)=km。所以 c(a-b) DIV d = km DIV d。因为GCD(c DIV d，m DIV d) = 1，所以((a - b) mod (m DIV d) )= 0，则a ≡ b(mod (m DIV d))。

  ![证明](https://i.loli.net/2020/09/05/T1fcSQjEl2Hopqi.png)

  * 例如，给出一个正整数m = 4和三个整数a = 3,b = 1和c = 6, GCD(c,m) = GCD(6 , 4) = 2，并且6 * 3 = 6 * 1(mod 4)。则3 ≡ 1(mod 2)。

* #### 推论1

  * 给出一个正整数m和三个整数a,b和c，GCD(c,m) = 1，并且ac ≡ bc (mod m)。则a ≡ b(mod m)。
  * 例如，给出一个正整数m = 3和三个整数 a = 4, b = 7和c = 2，GCD(c,m) = GCD(2,3) = 1，并且4 * 2 = 7 * 2(mod 3)。则4 ≡ 7(mod 3)。

* #### 推论2

  * 给出一个正整数d和两个整数a和b，如果ad ≡ bd (mod md)，则a ≡ b(mod m)。
  * 如上面的例子，10 ≡ 4 (mod 6)，但如果两边同时除以2，就不能保持同余；但5 ≡ 2 (mod 3)。
  
* #### 同余类
  
  * 给出一个整数集Z和一个正整数m，模m同余满足自反性，对称性和传递性。所以Z可以被划分为**m个不相交的子集**[0,m-1]，这些子集被称为模m的同余类，每个同余类中任意两个整数都是模m同余的。
  * 自反性：a≡a(mod m)
  * 对称性：a≡b(mod m)   则  b≡a(mod m)
  * 传递性：a≡b(mod m)   且  b≡c(mod m)  则  a≡c(mod m)

* #### 由同余理论，模运算规则如下

  * (a + b) % p = (a % p + b % p) % p
  * (a - b) % p = (a % p - b % p) % p
  * (a * b) % p = (a % p * b % p) % p
  * (a^b) % p = ((a%p)^b) % p

  > 注意这里出发不能拆开进行模运算，而且指数运算中指数不能模p

* #### 结合律

  * ((a+b)%p+c)%p = (a+(b+c)%p)%p
  * ((a\*b)%p\*c)%p = (a\*(b\*c)%p)%p

* #### 分配律

  * ((a+b)%p\*c)%p = ((a\*c)%p+(b\*c)%p)%p

# Raising Modulo Numbers(POJ 1995)

* #### 描述

  给出n对数字A<sub>i</sub>和B<sub>i</sub>，1 $\leq$ i $\leq$ n；以及一个整数M。请您求解(A<sub>1</sub><sup>B<sub>1</sub></sup>+A<sub>2</sub><sup>B<sub>2</sub></sup>+......+A<sub>n</sub><sup>B<sub>n</sub></sup>)mod M。

* #### 输入

  输入包含Z个测试用例，在输入的第一行给出正整数Z。接下来给出每个测试用例。每个测试用例的第一行给出整数M(1 $\leq$ M $\leq$ 45000)。总和将除以这个数取余数；接下来的一行给出数字的堆数H(1 $\leq$ H $\leq$ 45000)；接下来的H行，在每一行给出两个被空格隔开的数字A<sub>i</sub>和B<sub>i</sub>，这两个数字不能同时等于零。

* #### 输出

  对于每一个测试用例，输出一行，式表达式(A<sub>1</sub><sup>B<sub>1</sub></sup>+A<sub>2</sub><sup>B<sub>2</sub></sup>+......+A<sub>n</sub><sup>B<sub>n</sub></sup>)mod M的结果。
  
* #### 代码

```cpp
#include <iostream>
#include <cstdio>
using namespace std;
int poo(int A,int B);
int m;
int main()
{
    int z;
    int h;
    scanf("%d",&z);
    int A,B;
    int ans = 0;
    for(int i = 1;i <= z;i ++)
    {
        ans = 0;
        scanf("%d",&m);
        scanf("%d",&h);
        for(int i = 1;i <= h;i ++)
        {
            scanf("%d%d",&A,&B);
            ans = (ans+poo(A,B))%m;
        }
        printf("%d\n",ans);
    }
    return 0;
}
int poo(int A,int B)
{
    int ans = 1;
    for(int i = 1;i <= B;i ++)
    {
        ans = (ans*A)%m;
    }
    return ans;
}
```

> 这样写思路是对的，但是TLE了，就是那个A<sup>B</sup>太费时间，这里顺便学习了一下快速幂的原理

# 快速幂

* #### 原理

  ![](https://i.loli.net/2020/09/05/3oursR56nB1lXey.png)

* #### 代码(模为m)

  ```cpp
  int fastPower(int base,int power)
  {
      int ans = 1;
      while(power > 0)
      {
          if(power % 2 != 0)
          {
              power -= 1;
              ans = (ans * (base%m))%m;
          }
          power /= 2;
          base = (base%m)*(base%m);
      }
      return ans;
  }
  ```

* #### 使用位运算优化代码(位运算更快)

  ```cpp
  int fastPower(int base,int power)
  {
      int ans = 1;
      while(power > 0)
      {
          if((power & 1) == 1)
          {
              power -= 1;
              ans = (ans * (base%m))%m;
          }
          power = power>>1;
          base = (base%m)*(base%m);
      }
      return ans;
  }
  ```

# 使用快速幂的POJ 1995

```cpp
#include <iostream>
#include <cstdio>
using namespace std;
int poo(int A,int B);
int m;
int main()
{
    int z;
    int h;
    scanf("%d",&z);
    int A,B;
    int ans = 0;
    for(int i = 1;i <= z;i ++)
    {
        ans = 0;
        scanf("%d",&m);
        scanf("%d",&h);
        for(int i = 1;i <= h;i ++)
        {
            scanf("%d%d",&A,&B);
            ans = (ans+poo(A,B))%m;
        }
        printf("%d\n",ans);
    }
    return 0;
}
int poo(int A,int B)
{
    int ans = 1;
    while(power > 0)
    {
        if((power & 1) == 1)
        {
            power -= 1;
            ans = (ans * (base%m))%m;
        }
        power = power>>1;
        base = (base%m)*(base%m);
    }
    return ans;
}
```

# 一元线性同余方程

* #### 定义

  形如ax ≡ b(mod m)的同余式被称为一元线性同余方程，其中a和b是整数，m是正整数，x未知整数。

* #### 定理1

  设a和b是整数，m是正整数，且GCD(a,m)=d。如果b mod d $\neq$ 0，则 ax ≡ b(mod m)无解；如果b mod d = 0，则ax ≡ b(mod m)恰有d个模m不同余的解。

